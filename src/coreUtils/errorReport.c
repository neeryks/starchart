// errorReport.c
// 
// -------------------------------------------------
// Copyright 2015-2022 Dominic Ford
//
// This file is part of StarCharter.
//
// StarCharter is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// StarCharter is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with StarCharter.  If not, see <http://www.gnu.org/licenses/>.
// -------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "asciiDouble.h"
#include "strConstants.h"

#include "errorReport.h"

static char temp_stringA[LSTR_LENGTH], temp_stringB[LSTR_LENGTH], temp_stringC[LSTR_LENGTH], temp_stringD[LSTR_LENGTH], temp_stringE[LSTR_LENGTH];
char temp_err_string[FNAME_LENGTH];

void stch_error(char *msg) {
    if ((msg != temp_stringA) && (msg != temp_stringB)) {
        strcpy(temp_stringA, msg);
        msg = temp_stringA;
    }
    if (DEBUG) {
        snprintf(temp_stringC, FNAME_LENGTH, "%s%s", "Error: ", msg);
        stch_log(temp_stringC);
    }
    snprintf(temp_stringC, FNAME_LENGTH, "Error: %s\n", msg);
    fputs(temp_stringC, stderr);
}

void stch_fatal(char *file, int line, char *msg) {
    char introline[FNAME_LENGTH];
    if (msg != temp_stringE) strcpy(temp_stringE, msg);
    snprintf(introline, FNAME_LENGTH, "Fatal Error encounted in %s at line %d:", file, line);
    stch_error(introline);
    stch_error(temp_stringE);
    if (DEBUG) stch_log("Terminating with error condition 1.");
    exit(1);
}

void stch_warning(char *msg) {
    if (msg != temp_stringA) strcpy(temp_stringA, msg);
    if (DEBUG) {
        snprintf(temp_stringC, FNAME_LENGTH, "%s%s", "Warning: ", temp_stringA);
        stch_log(temp_stringC);
    }
    snprintf(temp_stringC, FNAME_LENGTH, "Warning: %s\n", temp_stringA);
    fputs(temp_stringC, stderr);
}

void stch_report(char *msg) {
    if (msg != temp_stringA) strcpy(temp_stringA, msg);
    if (DEBUG) {
        snprintf(temp_stringC, FNAME_LENGTH, "%s%s", "Reporting: ", temp_stringA);
        stch_log(temp_stringC);
    }
    snprintf(temp_stringC, FNAME_LENGTH, "%s\n", temp_stringA);
    fputs(temp_stringC, stdout);
}

void stch_log(char *msg) {
    static FILE *logfile = NULL;
    static int latch = 0;
    char linebuffer[LSTR_LENGTH];

    if (latch) return; // Do not allow recursive calls, which might be generated by the call to stch_fatal below
    latch = 1;
    if (logfile == NULL) {
        if ((logfile = fopen("starchart.log", "w")) == NULL) {
            stch_fatal(__FILE__, __LINE__, "Could not open log file to write.");
            exit(1);
        }
        setvbuf(logfile, NULL, _IOLBF, 0); // Set log file to be line-buffered, so that log file is always up-to-date
    }

    if (msg != temp_stringD) strcpy(temp_stringD, msg);
    fprintf(logfile, "[%s] %s\n", str_strip(friendly_time_string(), linebuffer), temp_stringD);
    latch = 0;
}

void dcf_fread(void *ptr, size_t size, size_t nmemb, FILE *stream) {
    if (fread(ptr, size, nmemb, stream) != nmemb) stch_fatal(__FILE__, __LINE__, "file read fail");
}
